
The map class is an associative container that holds key-value pairs, where keys must be unique within the container.

There are a number of ways to populate a map container. Consider a map defined like this:

\begin{lstlisting}[style=styleCXX]
map<string, string> m;
\end{lstlisting}

You can add an element with the [] operator:

\begin{lstlisting}[style=styleCXX]
m["Miles"] = "Trumpet"
\end{lstlisting}

You can use the insert() member function:

\begin{lstlisting}[style=styleCXX]
m.insert(pair<string,string>("Hendrix", "Guitar"));
\end{lstlisting}

Or, you can use the emplace() member function:

\begin{lstlisting}[style=styleCXX]
m.emplace("Krupa", "Drums");
\end{lstlisting}

I tend to gravitate toward the emplace() function. Introduced with C++11, emplace() uses perfect forwarding to emplace (create in place) the new element for the container. The parameters are forwarded directly to the element constructors. This is quick, efficient, and easy to code.
 
Though it's certainly an improvement over the other options, the problem with emplace() is that it constructs an object even when it's not needed. This involves calling the constructors, allocating memory, and moving data around, and then discarding that temporary object.

To solve this problem, C++17 provides the new try\_emplace() function which only constructs the value object if it's needed. This is especially important with large objects or many emplacements.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black,title=Note]
Each element of a map is a key-value pair. Within the pair structure, the elements are named, first and second, but their purpose in the map is key and value. I tend to think of the value object as the payload, as this is usually the point of the map. To search for an existing key, the try\_emplace() function must construct the key object; this cannot be avoided. But it need not construct the payload object unless and until it's needed for insertion into the map.
\end{tcolorbox}

\subsubsection{How to do it…}

The new try\_emplace() function avoids the overhead of constructing the payload object unless and until it is needed. This creates a valuable efficiency in the case of key collisions, especially with large payloads. Let's take a look:

\begin{itemize}
\item 
First, we create a payload class. For demonstration purposes, this class has a simple std::string payload and displays a message when constructed:

\begin{lstlisting}[style=styleCXX]
struct BigThing {
	string v_;
	BigThing(const char * v) : v_(v) {
		cout << format("BigThing constructed {}\n", v_);
	}
};
using Mymap = map<string, BigThing>;
\end{lstlisting}

This BigThing class has only one member function, a constructor that displays a message when the object is constructed. We'll use this to keep track of how often a BigThing object is constructed. In practice, of course, this class would be bigger, and use more resources.

Each map element will consist of a pair of objects, a std::string for the key and a BigThing object for the payload. Mymap is just a convenience alias. This allows us to focus on function rather than form.

\item 
We'll also create a printm() function to print the contents of the map:

\begin{lstlisting}[style=styleCXX]
void printm(Mymap& m) {
	for(auto& [k, v] : m) {
		cout << format("[{}:{}] ", k, v.v_);
	}
	cout << "\n";
}
\end{lstlisting}

This uses the C++20 format() function to print out the map, so we can keep track of the elements as we insert them.

\item 
In our main() function we create the map object and insert some elements:

\begin{lstlisting}[style=styleCXX]
int main() {
	Mymap m;
	m.emplace("Miles", "Trumpet");
	m.emplace("Hendrix", "Guitar");
	m.emplace("Krupa", "Drums");
	m.emplace("Zappa", "Guitar");
	m.emplace("Liszt", "Piano");
	printm(m);
}
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
BigThing constructed Trumpet
BigThing constructed Guitar
BigThing constructed Drums
BigThing constructed Guitar
BigThing constructed Piano
[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano]
[Miles:Trumpet] [Zappa:Guitar]
\end{tcblisting}

Our output shows the construction of each of the payload objects, and then the output from the printm() function call.

\item 
I used the emplace() function to add the elements to the map, and each payload element was constructed just once. We can use the try\_emplace() function and the result will be the same:

\begin{lstlisting}[style=styleCXX]
Mymap m;
m.try_emplace("Miles", "Trumpet");
m.try_emplace("Hendrix", "Guitar");
m.try_emplace("Krupa", "Drums");
m.try_emplace("Zappa", "Guitar");
m.try_emplace("Liszt", "Piano");
printm(m);
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
BigThing constructed Trumpet
BigThing constructed Guitar
BigThing constructed Drums
BigThing constructed Guitar
BigThing constructed Piano
[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano]
[Miles:Trumpet] [Zappa:Guitar]
\end{tcblisting}

\item 
The difference between emplace() and try\_emplace() shows up when we try to insert new elements with duplicate keys:

\begin{lstlisting}[style=styleCXX]
cout << "emplace(Hendrix)\n";
m.emplace("Hendrix", "Singer");
cout << "try_emplace(Zappa)\n";
m.try_emplace("Zappa", "Composer");
printm(m);
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
emplace(Hendrix)
BigThing constructed Singer
try_emplace(Zappa)
[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano]
[Miles:Trumpet] [Zappa:Guitar]
\end{tcblisting}

The emplace() function tried to add an element with a duplicate key ("Hendrix"). It failed but still constructed the payload object ("Singer"). The try\_emplace() function also tried to add an element with a duplicate key ("Zappa"). It failed and did not construct the payload object.
\end{itemize}

This example demonstrates the distinction between emplace() and try\_emplace().

\subsubsection{How it works…}

The try\_emplace() function signature is similar to that of emplace(), so it should be easy to retrofit legacy code. Here's the try\_emplace() function signature:

\begin{lstlisting}[style=styleCXX]
pair<iterator, bool> try_emplace( const Key& k,
Args&&... args );
\end{lstlisting}

At first glance, this looks different from the emplace() signature:

\begin{lstlisting}[style=styleCXX]
pair<iterator,bool> emplace( Args&&... args );
\end{lstlisting}

The distinction is that try\_emplace() uses a separate parameter for the key argument, which allows it to be isolated for construction. Functionally, if you're using template argument deduction, try\_emplace() can be a drop-in replacement:

\begin{lstlisting}[style=styleCXX]
m.emplace("Miles", "Trumpet");
m.try_emplace("Miles", "Trumpet");
\end{lstlisting}

The return value of try\_emplace() is the same as that of emplace(), a pair representing an iterator and a bool:

\begin{lstlisting}[style=styleCXX]
const char * key{"Zappa"};
const char * payload{"Composer"};
if(auto [it, success] = m.try_emplace(key, payload);
!success) {
	cout << "update\n";
	it->second = payload;
}
printm(m);
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
update
BigThing constructed Composer
[Hendrix:Guitar] [Krupa:Drums] [Liszt:Piano] [Miles:Trumpet]
[Zappa:Composer]
\end{tcblisting}

Here I used structured binding (auto [it, success] =) with an if initializer statement to test the return value and conditionally update the payload. Notice that it still just constructs the payload object once.

It's worth noting that the try\_emplace() function also works with unordered\_map.
We change our alias and everything works the same except unordered:

\begin{lstlisting}[style=styleCXX]
using Mymap = unordered_map<string, BigThing>;
\end{lstlisting}

The advantage of try\_emplace() is that it only constructs the payload object if and when it's ready to store it in the map. In practice, this should save significant resources at run-time. You should always favor try\_emplace() over emplace().




















