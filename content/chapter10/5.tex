
To demonstrate traversing and searching directory structures, we create a simple utility that works like Unix grep. This utility uses recursive\_directory\_iterator to traverse nested directories and searches files for matches with a regular expression.

\subsubsection{How to do it…}

In this recipe, we write a simple grep utility that traverses directories to search files with a regular expression:

\begin{itemize}
\item 
We start with some convenience aliases:

\begin{lstlisting}[style=styleCXX]
namespace fs = std::filesystem;
using de = fs::directory_entry;
using rdit = fs::recursive_directory_iterator;
using match_v = vector<std::pair<size_t, std::string>>;
\end{lstlisting}

match\_v is a vector of regular expression match results.

\item 
We continue using our formatter specialization for path objects:

\begin{lstlisting}[style=styleCXX]
template<>
struct std::formatter<fs::path>:
std::formatter<std::string> {
	template<typename FormatContext>
	auto format(const fs::path& p, FormatContext& ctx) {
		return format_to(ctx.out(), "{}", p.string());
	}
};
\end{lstlisting}

\item 
We have a simple function for getting regular expression matches from a file:

\begin{lstlisting}[style=styleCXX]
match_v matches(const fs::path& fpath, const regex& re) {
	match_v matches{};
	std::ifstream instrm(fpath.string(),
		std::ios_base::in);
	string s;
	for(size_t lineno{1}; getline(instrm, s); ++lineno) {
		if(std::regex_search(s.begin(), s.end(), re)) {
			matches.emplace_back(lineno, move(s));
		}
	}
	return matches;
}
\end{lstlisting}

In this function, we open the file with ifstream, read lines from the file with getline(), and match the regular expression with regex\_search(). Results are collected in the vector and returned.

\item 
We can now call this function from main():

\begin{lstlisting}[style=styleCXX]
int main() {
	constexpr const char * fn{ "working.cpp" };
	constexpr const char * pattern{ "path" };
	
	fs::path fpath{ fn };
	regex re{ pattern };
	auto regmatches{ matches(fpath, re) };
	for(const auto& [lineno, line] : regmatches) {
		cout << format("{}: {}\n", lineno, line);
	}
	cout << format("found {} matches\n", regmatches.
	size());
}
\end{lstlisting}

In this example, we use constants for the filename and the regular expression pattern. We create path and regex objects, call the matches() function, and print the results.

Our output has line numbers and strings for the matching lines:

\begin{tcblisting}{commandshell={}}
25: struct std::formatter<fs::path>:
std::formatter<std::string> {
27: auto format(const fs::path& p, FormatContext&
ctx) {
32: match_v matches(const fs::path& fpath, const regex&
re) {
34: std::ifstream instrm(fpath.string(), std::ios_
base::in);
62: constexpr const char * pattern{ "path" };
64: fs::path fpath{ fn };
66: auto regmatches{ matches(fpath, re) };
\end{tcblisting}

\item 
Our utility needs to take command-line arguments for the regex pattern and filenames. It should be able to traverse directories or take a list of filenames (which may be the result of command-line wildcard expansion). This requires a bit of logic in the main() function.

First, we need one more helper function:

\begin{lstlisting}[style=styleCXX]
size_t pmatches(const regex& re, const fs::path& epath,
const fs::path& search_path) {
	fs::path target{epath};
	auto regmatches{ matches(epath, re) };
	auto matchcount{ regmatches.size() };
	if(!matchcount) return 0;
	
	if(!(search_path == epath)) {
		target =
		epath.lexically_relative(search_path);
	}
	for (const auto& [lineno, line] : regmatches) {
		cout << format("{} {}: {}\n", target, lineno,
		line);
	}
	return regmatches.size();
}
\end{lstlisting}

This function calls our matches() function and prints the results. It takes a regex object and two path objects. epath is the result of a directory search, and search\_path is the search directory itself. We'll set these in main().

\item 
In main(), we use the argc and argv command-line arguments and we declare a few variables:

\begin{lstlisting}[style=styleCXX]
int main(const int argc, const char** argv) {
	const char * arg_pat{};
	regex re{};
	fs::path search_path{};
	size_t matchcount{};
	...
\end{lstlisting}

The variables declared here are:

\begin{itemize}
\item
arg\_pat is for the regular expression pattern from the command line

\item
re is the regex object

\item
search\_path is the command-line search path argument

\item
matchcount is for counting the matched lines
\end{itemize}

\item 
Continuing in main(), if we have no arguments, then we print a short usage string:

\begin{lstlisting}[style=styleCXX]
if(argc < 2) {
	auto cmdname{ fs::path(argv[0]).filename() };
	cout << format("usage: {} pattern [path/file]\n",
		cmdname);
	return 1;
}
\end{lstlisting}

argv[1] is always the invoking command from the command line. cmdname uses the filename() method to return a path with just the filename part of the invoking command path.

\item 
Next, we parse the regular expression. We use a try-catch block to capture any error from the regex parser:

\begin{lstlisting}[style=styleCXX]
arg_pat = argv[1];
try {
	re = regex(arg_pat, std::regex_constants::icase);
} catch(const std::regex_error& e) {
	cout << format("{}: {}\n", e.what(), arg_pat);
	return 1;
}
\end{lstlisting}

We use the icase flag to tell the regex parser to ignore case.

\item 
If argc == 2, we have just one argument, which we treat as the regular expression pattern, and we use the current directory for the search path:

\begin{lstlisting}[style=styleCXX]
if(argc == 2) {
	search_path = ".";
	for (const auto& entry : rdit{ search_path }) {
		const auto epath{ entry.path() };
		matchcount += pmatches(re, epath,
		search_path);
	}
}
\end{lstlisting}

rdit is an alias for the recursive\_directory\_iterator class, which traverses the directory tree from the starting path, returning a directory\_entry object for each file it encounters. We then create a path object and call pmatches() to go through the file and print any regular expression matches.

\item 
At this point in main(), we know that argc is >=2. Now, we handle cases where we have one or more file paths on the command line:

\begin{lstlisting}[style=styleCXX]
int count{ argc - 2 };
while(count-- > 0) {
	fs::path p{ argv[count + 2] };
	if(!exists(p)) {
		cout << format("not found: {}\n", p);
		continue;
	}
	if(is_directory(p)) {
		for (const auto& entry : rdit{ p }) {
			const auto epath{ entry.path() };
			matchcount += pmatches(re, epath, p);
		}
	} else {
		matchcount += pmatches(re, p, p);
	}
}
\end{lstlisting}

The while loop handles one or more arguments past the search pattern on the command line. It checks each filename to ensure it exists. Then, if it's a directory, it uses the rdit alias for the recursive\_directory\_iterator class to traverse the directory and call pmatches() to print any pattern matches in the files.

If it's a single file, it calls pmatches() on that file.

\item 
We can run our grep clone with one argument as the search pattern:

\begin{tcblisting}{commandshell={}}
$ ./bwgrep using
dir.cpp 12: using std::format;
dir.cpp 13: using std::cout;
dir.cpp 14: using std::string;
...
formatter.cpp 10: using std::cout;
formatter.cpp 11: using std::string;
formatter.cpp 13: using namespace std::filesystem;
found 33 matches
\end{tcblisting}

We can run it with a second argument as a directory to search:

\begin{tcblisting}{commandshell={}}
$ ./bwgrep using ..
chap04/iterator-adapters.cpp 12: using std::format;
chap04/iterator-adapters.cpp 13: using std::cout;
chap04/iterator-adapters.cpp 14: using std::cin;
...
chap01/hello-version.cpp 24: using std::print;
chap01/chrono.cpp 8: using namespace std::chrono_
literals;
chap01/working.cpp 15: using std::cout;
chap01/working.cpp 34: using std::vector;
found 529 matches
\end{tcblisting}

Notice that it traverses the directory tree to find files in sub-directories.

Or we can run it with a single file argument:

\begin{tcblisting}{commandshell={}}
$ ./bwgrep using bwgrep.cpp
bwgrep.cpp 13: using std::format;
bwgrep.cpp 14: using std::cout;
bwgrep.cpp 15: using std::string;
...
bwgrep.cpp 22: using rdit = fs::recursive_directory_
iterator;
bwgrep.cpp 23: using match_v = vector<std::pair<size_t,
std::string>>;
found 9 matches
\end{tcblisting}

\end{itemize}

\subsubsection{How it works…}

While the main task of this utility is the regular expression matching, we're concentrating on the technique of recursively processing directories of files.

The recursive\_directory\_iterator object is interchangeable with directory\_iterator, except recursive\_directory\_iterator operates recursively over all the entries of each sub-directory.

\subsubsection{See also…}

For more about regular expressions, see the recipe Parse strings with Regular Expressions in Chapter 7, Strings, Streams, and Formatting.












