
An iterator is essentially an abstraction. It has a specific interface and is used in specific ways. But beyond that, it's just code and it can be used for other purposes. An iterator adapter is a class that looks like an iterator but does something else.

The STL comes with an assortment of iterator adapters. Often used with the algorithm library, they are quite useful. The STL iterator adaptors generally fall into three categories:

\begin{itemize}
\item 
Insert iterators, or inserters, are used to insert elements into a container.

\item 
Stream iterators read from and write to a stream.

\item 
Reverse iterators reverse the direction of an iterator.
\end{itemize}

\subsubsection{How to do it…}

In this recipe, we'll look at a few examples of STL iterator adapters:

\begin{itemize}
\item 
We'll start with a simple function to print the contents of a container:

\begin{lstlisting}[style=styleCXX]
void printc(const auto & v, const string_view s = "") {
	if(s.size()) cout << format("{}: ", s);
	for(auto e : v) cout << format("{} ", e);
	cout << '\n';
}
\end{lstlisting}

The printc() function allows us to easily view the results of our algorithms. It includes an optional string\_view argument for a description.

\item 
In our main() function, we'll define a couple of deque containers. We're using deque containers so we can insert at both ends:

\begin{lstlisting}[style=styleCXX]
int main() {
	deque<int> d1{ 1, 2, 3, 4, 5 };
	deque<int> d2(d1.size());
	copy(d1.begin(), d1.end(), d2.begin());
	printc(d1);
	printc(d2, "d2 after copy");
}
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
1 2 3 4 5
d2 after copy: 1 2 3 4 5
\end{tcblisting}

We defined deque d1 with five int values, and d2 with space for the same number of elements. The copy() algorithm will not allocate space, so d2 must have room for the elements.

The copy() algorithm takes three iterators: the begin and end iterators indicate the range of elements to copy from, and the begin iterator of the destination range. It does not check the iterators to make sure they're valid. (Try this without allocating space in a vector and you'll get a segmentation fault error.) 

We call printc() on both containers to show the results.

\item 
The copy() algorithm is not always convenient for this. Sometimes you want to copy and add elements to the end of a container. It would be nice to have an algorithm that calls push\_back() for each element. This is where an iterator adapter is useful. Let's add some code at the end of main():

\begin{lstlisting}[style=styleCXX]
copy(d1.begin(), d1.end(), back_inserter(d2));
printc(d2, "d2 after back_inserter");
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
d2 after back_inserter: 1 2 3 4 5 1 2 3 4 5
\end{tcblisting}

back\_inserter() is an insert iterator adapter that calls push\_back() for each item assigned to it. You can use it anywhere an output iterator is expected.

\item 
There's also a front\_inserter() adapter for when you want to insert at the front of a container:

\begin{lstlisting}[style=styleCXX]
deque<int> d3{ 47, 73, 114, 138, 54 };
copy(d3.begin(), d3.end(), front_inserter(d2));
printc(d2, "d2 after front_inserter");
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
d2 after front_inserter: 54 138 114 73 47 1 2 3 4 5 1 2 3 4 5
\end{tcblisting}

The front\_inserter() adapter inserts elements at the front using the container's push\_front() method. Notice that the elements in the destination are reversed, because each element is inserted before the previous one.

\item 
If we want to insert in the middle, we can use the inserter() adapter:

\begin{lstlisting}[style=styleCXX]
auto it2{ d2.begin() + 2};
copy(d1.begin(), d1.end(), inserter(d2, it2));
printc(d2, "d2 after middle insert");
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
d2 after middle insert: 54 138 1 2 3 4 5 114 73 47 ...
\end{tcblisting}

The inserter() adapter takes an iterator for the insertion begin point.

\item 
Stream iterators are convenient for reading from and writing to iostream objects, this is ostream\_iterator():

\begin{lstlisting}[style=styleCXX]
cout << "ostream_iterator: ";
copy(d1.begin(), d1.end(), ostream_iterator<int>(cout));
cout << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
ostream_iterator: 12345
\end{tcblisting}

\item 
And here is istream\_iterator():

\begin{lstlisting}[style=styleCXX]
vector<string> vs{};
copy(istream_iterator<string>(cin),
	istream_iterator<string>(),
	back_inserter(vs));
printc(vs, "vs2");
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
$ ./working < five-words.txt
vs2: this is not a haiku
\end{tcblisting}

The istream\_iterator() adapter will return an end iterator by default, if no stream is passed.

\item 
Reverse adapters are included with most containers, as function members rbegin() and rend():

\begin{lstlisting}[style=styleCXX]
for(auto it = d1.rbegin(); it != d1.rend(); ++it) {
	cout << format("{} ", *it);
}
cout << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
5 4 3 2 1
\end{tcblisting}
\end{itemize}

\subsubsection{How it works…}

The iterator adapters work by wrapping around an existing container. When you call an adapter, like back\_inserter() with a container object:

\begin{lstlisting}[style=styleCXX]
copy(d1.begin(), d1.end(), back_inserter(d2));
\end{lstlisting}

The adapter returns an object that mimics an iterator, in this case a std::back\_insert\_iterator object, which calls the push\_back() method on the container object each time a value is assigned to the iterator. This allows the adapter to be used in place of an iterator, while performing its useful task.

The istream\_adapter() also requires a sentinel. A sentinel signals the end of an iterator of indeterminate length. When you read from a stream, you don't know how many objects are in the stream until you hit the end. When the stream hits the end, the sentinel will compare equal with the iterator, signaling the end of the stream. The istream\_adapter() will create a sentinel when it's called without a parameter:

\begin{lstlisting}[style=styleCXX]
auto it = istream_adapter<string>(cin);
auto it_end = istream_adapter<string>(); // creates sentinel
\end{lstlisting}

This allows you to test for the end of a stream, as you would with any container:

\begin{lstlisting}[style=styleCXX]
for(auto it = istream_iterator<string>(cin);
		it != istream_iterator<string>();
		++it) {
	cout << format("{} ", *it);
}
cout << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
$ ./working < five-words.txt
this is not a haiku
\end{tcblisting}

