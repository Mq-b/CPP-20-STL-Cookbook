
A generator is an iterator that generates its own sequence of values. It does not use a container. It creates values on the fly, returning one at a time as needed. A C++ generator stands on its own; it does not need to wrap around another object.

In this recipe, we'll build a generator for a Fibonacci sequence. This is a sequence where each number is the sum of the previous two numbers in the sequence, starting with 0 and 1:

\begin{equation*}
F(n)=
\begin{cases}
	0, n = 0 \\
	1, n = 1 \\
	F(n-1) + F(n-2), n > 1
\end{cases}
\end{equation*}

The first ten values of the Fibonacci sequence, not counting zero, are: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. This is a close approximation of the golden ratio found in nature.

\subsubsection{How to do it…}

A Fibonacci sequence is often created with a recursive loop. Recursion in a generator can be difficult and resource-intensive, so instead we'll just save the previous two values in the sequence and add them together. This is more efficient.

\begin{itemize}
\item 
First let's define a function to print the sequence:

\begin{lstlisting}[style=styleCXX]
void printc(const auto & v, const string_view s = "") {
	if(s.size()) cout << format("{}: ", s);
	for(auto e : v) cout << format("{} ", e);
	cout << '\n';
}
\end{lstlisting}

We've used this printc() function before. It prints an iterable range, along with a description string, if provided.

\item 
Our class begins with a type alias, and a few object variables, all in the private section.

\begin{lstlisting}[style=styleCXX]
class fib_generator {
	using fib_t = unsigned long;
	fib_t stop_{};
	fib_t count_ { 0 };
	fib_t a_ { 0 };
	fib_t b_ { 1 };
\end{lstlisting}

The stop\_ variable will be used later as a sentinel. It's set to the number of values to generate. count\_ is used to keep track of how many values we've generated. a\_ and b\_ are the previous two sequence values, used for calculating the next value.

\item 
Still in the private section, we have a simple function for calculating the next value in the Fibonacci sequence.

\begin{lstlisting}[style=styleCXX]
	constexpr void do_fib() {
		const fib_t old_b = b_;
		b_ += a_;
		a_ = old_b;
	}
\end{lstlisting}

\item 
Now in the public section, we have a simple constructor with a default value:

\begin{lstlisting}[style=styleCXX]
public:
	explicit fib_generator(fib_t stop = 0) : stop_{ stop
	} {}
\end{lstlisting}

This constructor is used without an argument to create a sentinel. The stop argument initializes the stop\_ variable to represent how many values to generate.

\item 
The rest of the public functions are the operator overloads expected of a forward iterator:

\begin{lstlisting}[style=styleCXX]
	fib_t operator*() const { return b_; }
	constexpr fib_generator& operator++() {
		do_fib();
		++count_;
		return *this;
	}
	fib_generator operator++(int) {
		auto temp{ *this };
		++*this;
		return temp;
	}
	bool operator!=(const fib_generator &o) const {
		return count_ != o.count_;
	}
	bool operator==(const fib_generator&o) const {
		return count_ == o.count_;
	}
	const fib_generator& begin() const { return *this; }
	const fib_generator end() const {
		auto sentinel = fib_generator();
		sentinel.count_ = stop_;
		return sentinel;
	}
	fib_t size() { return stop_; }
};
\end{lstlisting}

There's also a simple size() function which can be useful if you need to initialize a target container for a copy operation.

\item 
Now we can use the generator in our main function with a simple call to

\begin{lstlisting}[style=styleCXX]
printc():
	int main() {
		printc(fib_generator(10));
	}
\end{lstlisting}

This creates an anonymous fib\_generator object to pass to the printc() function.

\item 
We get this output with the first 10 Fibonacci numbers, not including zero:

\begin{tcblisting}{commandshell={}}
1 1 2 3 5 8 13 21 34 55
\end{tcblisting}
\end{itemize}

\subsubsection{How it works…}

The fib\_generator class operates as a forward iterator, simply because it provides all the necessary interface functions:

\begin{lstlisting}[style=styleCXX]
fib_generator {
public:
	fib_t operator*() const;
	constexpr fib_generator& operator++();
	fib_generator operator++(int);
	bool operator!=(const fib_generator &o) const;
	bool operator==(const fib_generator&o) const;
	const fib_generator& begin() const;
	const fib_generator end() const;
};
\end{lstlisting}

As far as the range-based for loop is concerned, this is an iterator because it looks like an iterator.

The value is calculated in the do\_fib() function:

\begin{lstlisting}[style=styleCXX]
constexpr void do_fib() {
	const fib_t old_b = b_;
	b_ += a_;
	a_ = old_b;
}
\end{lstlisting}

This simply adds b\_ += a\_, stores the result in b\_ and the old b\_ in a\_, setting it up for the next iteration.

The dereference operator * returns the value from b\_, which is the next value in the sequence:

\begin{lstlisting}[style=styleCXX]
fib_t operator*() const { return b_; }
\end{lstlisting}

The end() function creates an object where the count\_ variable is equal to the stop\_ variable, creating a sentinel:

\begin{lstlisting}[style=styleCXX]
const fib_generator end() const {
	auto sentinel = fib_generator();
	sentinel.count_ = stop_;
	return sentinel;
}
\end{lstlisting}

Now the equality comparison operator can easily detect the end of the sequence:

\begin{lstlisting}[style=styleCXX]
bool operator==(const fib_generator&o) const {
	return count_ == o.count_;
}
\end{lstlisting}

\subsubsection{There's more…}

If we want to make our generator work with the algorithm library, we need to provide the traits aliases. These go at the top of the public section:

\begin{lstlisting}[style=styleCXX]
public:
	using iterator_concept = std::forward_iterator_tag;
	using iterator_category = std::forward_iterator_tag;
	using value_type = std::remove_cv_t<fib_t>;
	using difference_type = std::ptrdiff_t;
	using pointer = const fib_t*;
	using reference = const fib_t&;
\end{lstlisting}

Now we can use our generator with algorithms:

\begin{lstlisting}[style=styleCXX]
fib_generator fib(10);
auto x = ranges::views::transform(fib,
	[](unsigned long x){ return x * x; });
printc(x, "squared:");
\end{lstlisting}

This uses the ranges::views version of the transform() algorithm to square every value. The resulting object can be used wherever you can use an iterator. We get this output from the printc() call:

\begin{tcblisting}{commandshell={}}
squared:: 1 1 4 9 25 64 169 441 1156 3025
\end{tcblisting}

