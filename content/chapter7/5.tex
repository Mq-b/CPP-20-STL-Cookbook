
The std::string class is a contiguous container, much like a vector or an array. It supports the contiguous\_iterator concept and all corresponding algorithms.

The string class is a specialization of basic\_string with a char type. This means that the elements of the container are of type char. Other specializations are available, but string is most common.

Because it is fundamentally a contiguous container of char elements, string may be used with the transform() algorithm, or any other technique that uses the contiguous\_iterator concept.

\subsubsection{How to do it…}

There are several ways to do transformations, depending on the application. This recipe will explore a few of them.

\begin{itemize}
\item 
We'll start with a few predicate functions. A predicate function takes a transformation element and returns a related element. For example, here is a simple predicate that returns an upper-case character:

\begin{lstlisting}[style=styleCXX]
char char_upper(const char& c) {
	return static_cast<char>(std::toupper(c));
}
\end{lstlisting}

This function is a wrapper around std::toupper(). Because the toupper() function returns an int and string elements are type char, we cannot use the toupper() function directly in a transformation.

Here is a corresponding char\_lower() function:

\begin{lstlisting}[style=styleCXX]
char char_lower(const char& c) {
	return static_cast<char>(std::tolower(c));
}
\end{lstlisting}

\item 
The rot13() function is a fun transformation predicate for demonstration purposes. It's a simple substitution cypher, not suitable for encryption but commonly used for obfuscation:

\begin{lstlisting}[style=styleCXX]
char rot13(const char& x) {
	auto rot13a = [](char x, char a)->char {
		return a + (x - a + 13) % 26;
	};
	if (x >= 'A' && x <= 'Z') return rot13a(x, 'A');
	if (x >= 'a' && x <= 'z') return rot13a(x, 'a');
	return x;
}
\end{lstlisting}

\item 
We can use these predicates with the transform() algorithm:

\begin{lstlisting}[style=styleCXX]
main() {
	string s{ "hello jimi\n" };
	cout << s;
	std::transform(s.begin(), s.end(), s.begin(),
		char_upper);
	cout << s;
	...
\end{lstlisting}

The transform() function calls char\_upper() with each element of s, puts the result back in s and transforms all the characters to uppercase: 

Output:

\begin{tcblisting}{commandshell={}}
hello jimi
HELLO JIMI
\end{tcblisting}

\item 
Instead of transform(), we can also use a simple for loop with a predicate function:

\begin{lstlisting}[style=styleCXX]
for(auto& c : s) c = rot13(c);
cout << s;
\end{lstlisting}

Starting with our uppercase string object, the result is:

\begin{tcblisting}{commandshell={}}
URYYB WVZV
\end{tcblisting}

\item 
The fun thing about the rot13 cypher is that it unscrambles itself. Because there are 26 letters in the ASCII alphabet, rotating 13 and then rotating 13 again results in the original string. Let's transform to lowercase and rot13 again to restore our string:

\begin{lstlisting}[style=styleCXX]
for(auto& c : s) c = rot13(char_lower(c));
cout << s;
\end{lstlisting}

Starting with our uppercase string object, the result is:

\begin{tcblisting}{commandshell={}}
hello jimi
\end{tcblisting}

Because of their uniform interface, the predicate functions may be chained as parameters of each other. We could also use char\_lower(rot13(c)) with the same result.

\item 
If your requirement is too complex for a simple character-by-character transformation, you may use string iterators as you would with any contiguous container. Here's a simple function that transforms a lowercase string to Title Case by capitalizing the first character and every character that follows a space:

\begin{lstlisting}[style=styleCXX]
string& title_case(string& s) {
	auto begin = s.begin();
	auto end = s.end();
	*begin++ = char_upper(*begin); // first element
	bool space_flag{ false };
	for(auto it{ begin }; it != end; ++it) {
		if(*it == ' ') {
			space_flag = true;
		} else {
			if(space_flag) *it = char_upper(*it);
			space_flag = false;
		}
	}
	return s;
}
\end{lstlisting}

Because it returns a reference to the transformed string, we can call it with cout, like this:

\begin{lstlisting}[style=styleCXX]
cout << title_case(s);
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
Hello Jimi
\end{tcblisting}

\end{itemize}

\subsubsection{How it works…}

The std::basic\_string class, and its specializations (including string), are supported by iterators fully compliant with contiguous\_iterator. This means that any technique that works with any contiguous container also works with string.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black,title=Note]
These transformations will not work with string\_view objects because the underlying data is const-qualified.
\end{tcolorbox}






















