
gather() is an example of an algorithm that leverages existing algorithms.

The gather() algorithm takes a pair of container iterators and moves the elements that satisfy a predicate toward a pivot position within the sequence, returning a pair of iterators that contains the elements that satisfy the predicate.

For example, we could use a gather algorithm to sort all the even numbers to the mid-point of a vector:

\begin{lstlisting}[style=styleCXX]
vector<int> vint{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
gather(vint.begin(), vint.end(), mid(vint), is_even);
for(const auto& el : vint) cout << el;
\end{lstlisting}

Our output is:

\begin{tcblisting}{commandshell={}}
1302468579
\end{tcblisting}

Notice that the even numbers are all in the middle of the output.

In this recipe, we will implement a gather algorithm using standard STL algorithms.

\subsubsection{How to do it…}

Our gather algorithm uses the std::stable\_partition() algorithm to move items before the pivot iterator and again to move items past the pivot.

\begin{itemize}
\item 
We put the algorithm in the bw namespace to avoid collisions.

\begin{lstlisting}[style=styleCXX]
namespace bw {
	using std::stable_partition;
	using std::pair;
	using std::not_fn;
	
	template <typename It, typename Pred>
	pair<It, It> gather(It first, It last, It pivot,
	Pred pred) {
		return {stable_partition(first, pivot, not_fn(pred)),
			stable_partition(pivot, last, pred)};
	}
};
\end{lstlisting}

The gather() algorithm returns a pair of iterators, returned from two calls to stable\_partition().

\item 
We also include some helper lambdas:

\begin{lstlisting}[style=styleCXX]
constexpr auto midit = [](auto& v) {
	return v.begin() + (v.end() - v.begin()) / 2;
};
constexpr auto is_even = [](auto i) {
	return i % 2 == 0;
};
constexpr auto is_even_char = [](auto c) {
	if(c >= '0' && c <= '9') return (c - '0') % 2 == 0;
	else return false;
};
\end{lstlisting}

These three lambdas are as follows:

\begin{itemize}
\item 
midit returns an iterator at the midpoint of a container, for use as a pivot point.

\item 
is\_even returns Boolean true if the value is even, for use as a predicate.

\item 
is\_even\_char returns Boolean true if the value is a character between '0' and '9' and is even, for use as a predicate.
\end{itemize}

\item 
We call gather() from the main() function with a vector of int like this:

\begin{lstlisting}[style=styleCXX]
int main() {
	vector<int> vint{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
	auto gathered_even = bw::gather(vint.begin(),
		vint.end(), bw::midit(vint), bw::is_even);
	for(const auto& el : vint) cout << el;
	cout << '\n';
}
\end{lstlisting}

Our output shows that the even numbers have been gathered in the middle:

\begin{tcblisting}{commandshell={}}
1302468579
\end{tcblisting}

The gather() function returns a pair of iterators that contain just the even values:

\begin{lstlisting}[style=styleCXX]
auto& [it1, it2] = gathered_even;
for(auto it{ it1 }; it < it2; ++it) cout << *it;
cout << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
02468
\end{tcblisting}

\item 
We can set the pivot point to the begin() or end() iterators:

\begin{lstlisting}[style=styleCXX]
bw::gather(vint.begin(), vint.end(), vint.begin(),
	bw::is_even);
for(const auto& el : vint) cout << el;
cout << '\n';
bw::gather(vint.begin(), vint.end(), vint.end(),
	bw::is_even);
for(const auto& el : vint) cout << el;
cout << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
0246813579
1357902468
\end{tcblisting}

\item 
Because gather() is iterator-based, we can use it with any container. Here's a string of character digits:

\begin{lstlisting}[style=styleCXX]
string jenny{ "867-5309" };
bw::gather(jenny.begin(), jenny.end(), jenny.end(),
	bw::is_even_char);
for(const auto& el : jenny) cout << el;
cout << '\n';
\end{lstlisting}

This moves all the even digits to the end of the string:

Output:

\begin{tcblisting}{commandshell={}}
7-539860
\end{tcblisting}

\end{itemize}

\subsubsection{How it works…}

The gather() function uses the std::stable\_partition() algorithm to move the elements that match the predicate to the pivot point.

gather() has two calls to stable\_partition(), one with the predicate, and one with the predicate negated:

\begin{lstlisting}[style=styleCXX]
template <typename It, typename Pred>
pair<It, It> gather(It first, It last, It pivot, Pred pred) {
	return { stable_partition(first, pivot, not_fn(pred)),
		stable_partition(pivot, last, pred) };
}
\end{lstlisting}

The iterators returned from the two stable\_partition() calls are returned in the pair.










