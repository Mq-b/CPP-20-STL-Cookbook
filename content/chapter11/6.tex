

When receiving input from users, it's common to end up with excessive consecutive whitespace characters in your strings. This recipe presents a function for removing consecutive spaces, even when it includes tabs or other whitespace characters.

\subsubsection{How to do it…}

This function leverages the std::unique() algorithm to remove consecutive whitespace characters from a string.

\begin{itemize}
\item 
In the bw namespace, we start with a function to detect whitespace:

\begin{lstlisting}[style=styleCXX]
template<typename T>
bool isws(const T& c) {
	constexpr const T whitespace[]{ " \t\r\n\v\f" };
	for(const T& wsc : whitespace) {
		if(c == wsc) return true;
	}
	return false;
}
\end{lstlisting}

This templated isws() function should work with any character type.

\item 
The delws() function uses std::unique() to erase consecutive whitespace in a string:

\begin{lstlisting}[style=styleCXX]
string delws(const string& s) {
	string outstr{s};
	auto its = unique(outstr.begin(), outstr.end(),
		[](const auto &a, const auto &b) {
			return isws(a) && isws(b);
		});
	outstr.erase(its, outstr.end());
	outstr.shrink_to_fit();
	return outstr;
}
\end{lstlisting}

delws() makes a copy of the input string, removes consecutive whitespace, and returns the new string.

\item 
We call it with a string from main():

\begin{lstlisting}[style=styleCXX]
int main() {
	const string s{ "big bad \t wolf" };
	const string s2{ bw::delws(s) };
	cout << format("[{}]\n", s);
	cout << format("[{}]\n", s2);
	return 0;
}
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
[big     bad                  wolf]
[big bad wolf]
\end{tcblisting}

\end{itemize}

\subsubsection{How it works…}

This function uses the std::unique() algorithm with a comparison lambda to find consecutive whitespace in a string object.

The comparison lambda calls our own isws() function to determine if we have found consecutive whitespace:

\begin{lstlisting}[style=styleCXX]
auto its = unique(outstr.begin(), outstr.end(),
	[](const auto &a, const auto &b) {
		return isws(a) && isws(b);
	});
\end{lstlisting}

We could use the isspace() function from the standard library, but it's a standard C function that depends on a narrowing type conversion from int to char. This may issue warnings on some modern C++ compilers and is not guaranteed to work without an explicit cast. Our isws() function uses a templated type and should work on any system, and with any specialization of std::string.