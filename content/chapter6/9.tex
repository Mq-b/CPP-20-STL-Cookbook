
There are many use cases for permutations, including testing, statistics, research, and more. The next\_permutation() algorithm generates permutations by re-ordering a container to the next lexicographical permutation.

\subsubsection{How to do it…}

For this recipe, we will print out the permutations of a set of three strings:

\begin{itemize}
\item 
We'll start by creating a short function for printing the contents of a container:

\begin{lstlisting}[style=styleCXX]
void printc(const auto& c, string_view s = "") {
	if(s.size()) cout << format("{}: ", s);
	for(auto e : c) cout << format("{} ", e);
	cout << '\n';
}
\end{lstlisting}

We'll use this simple function to print our data set and permutations.

\item 
In the main() function, we declare a vector of string objects and sort it with the sort() algorithm.

\begin{lstlisting}[style=styleCXX]
int main() {
	vector<string> vs{ "dog", "cat", "velociraptor" };
	sort(vs.begin(), vs.end());
	...
}
\end{lstlisting}

The next\_permutation() function requires a sorted container.

\item 
Now we can list the permutations with next\_permutation() in a do loop:

\begin{lstlisting}[style=styleCXX]
do {
	printc(vs);
} while (next_permutation(vs.begin(), vs.end()));
\end{lstlisting}

The next\_permutation() function modifies the container and returns true if there is another permutation, or false if not.

The output lists six permutations of our three pets:

\begin{tcblisting}{commandshell={}}
cat dog velociraptor
cat velociraptor dog
dog cat velociraptor
dog velociraptor cat
velociraptor cat dog
velociraptor dog cat
\end{tcblisting}
\end{itemize}

\subsubsection{How it works…}

The std::next\_permutation() algorithm generates lexicographical permutations of a set of values, that is, permutations based on dictionary ordering. The input must be sorted because the algorithm steps through permutations in lexicographical order. So, if you start with a set like 3, 2, 1, it will terminate immediately as this is the last lexicographical order of those three elements.

For example:

\begin{lstlisting}[style=styleCXX]
vector<string> vs{ "velociraptor", "dog", "cat" };
do {
	printc(vs);
} while (next_permutation(vs.begin(), vs.end()));
\end{lstlisting}

This gives us the following output:

\begin{tcblisting}{commandshell={}}
velociraptor dog cat
\end{tcblisting}

While the term lexicographical implies alphabetical ordering, the implementation uses standard comparison operators, so it works on any sortable values.

Likewise, if values in the set repeat, they are only counted according to lexicographical order. Here we have a vector of int with two repeating sequences of five values:

\begin{lstlisting}[style=styleCXX]
vector<int> vi{ 1, 2, 3, 4, 5, 1, 2, 3, 4, 5 };
sort(vi.begin(), vi.end());
printc(vi, "vi sorted");
long count{};
do {
	++count;
} while (next_permutation(vi.begin(), vi.end()));
cout << format("number of permutations: {}\n", count);
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
Vi sorted: 1 1 2 2 3 3 4 4 5 5
number of permutations: 113400
\end{tcblisting}

There are 113,400 permutations of these values. Notice that it's not 10! (3,628,800) because some values repeat. Since 3,3 and 3,3 sort the same, they are not different lexicographical permutations.

In other words, if I list the permutations of this short set:

\begin{lstlisting}[style=styleCXX]
vector<int> vi2{ 1, 3, 1 };
sort(vi2.begin(), vi2.end());
do {
	printc(vi2);
} while (next_permutation(vi2.begin(), vi2.end()));
\end{lstlisting}

We get only three permutations, not 3! (9), because of the repeating values:

\begin{tcblisting}{commandshell={}}
1 1 3
1 3 1
3 1 1
\end{tcblisting}






