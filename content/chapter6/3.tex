
Sometimes, there is no algorithm in the library to accomplish a task at hand. We can use iterators, with the same techniques as the algorithms library, to easily write one.

For example, we often need to join elements from a container, with separators, into a string. One common solution is to use a simple for() loop:

\begin{lstlisting}[style=styleCXX]
for(auto v : c) cout << v << ', ';
\end{lstlisting}

The problem with this otherwise simple solution is that it leaves a trailing separator:

\begin{lstlisting}[style=styleCXX]
vector<string> greek{ "alpha", "beta", "gamma",
	"delta", "epsilon" };
for(auto v : greek) cout << v << ", ";
cout << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
alpha, beta, gamma, delta, epsilon,
\end{tcblisting}

This may be fine in a testing environment, but in any production system, that trailing comma is unacceptable.

The ranges::views library has a join() function, but it doesn't provide a separator:

\begin{lstlisting}[style=styleCXX]
auto greek_view = views::join(greek);
\end{lstlisting}

The views::join() function returns a ranges::view object. This requires a separate step to display or turn into a string. We can cycle through the view with a for() loop:

\begin{lstlisting}[style=styleCXX]
for(const char c : greek_view) cout << c;
cout << '\n';
\end{lstlisting}

The output looks like this:

\begin{tcblisting}{commandshell={}}
alphabetagammadeltaepsilon
\end{tcblisting}

It's all there, but we need a proper separator between the elements to make it useful for our purposes.

Since the algorithms library does not have a function that suits our needs, we'll write one.

\subsubsection{How to do it…}

For this recipe, we will take the elements of a container and join them into a string with separators:

\begin{itemize}
\item 
In our main() function, we declare a vector of strings:

\begin{lstlisting}[style=styleCXX]
int main() {
	vector<string> greek{ "alpha", "beta", "gamma",
		"delta", "epsilon" };
	...
}
\end{lstlisting}

\item 
Now, let's write a simple join() function that uses an ostream object to join elements with a separator:

\begin{lstlisting}[style=styleCXX]
namespace bw {
	template<typename I>
	ostream& join(I it, I end_it, ostream& o,
				string_view sep = "") {
		if(it != end_it) o << *it++;
		while(it != end_it) o << sep << *it++;
		return o;
	}
}
\end{lstlisting}

I've put this in my own bw namespace to avoid name collisions.

We can call it with cout like this:

\begin{lstlisting}[style=styleCXX]
bw::join(greek.begin(), greek.end(), cout, ", ") << '\n';
\end{lstlisting}

Because it returns the ostream object, we can follow it with << to add a newline to the stream.

Output:

\begin{tcblisting}{commandshell={}}
alpha, beta, gamma, delta, epsilon
\end{tcblisting}

\item 
We'll often want a string, instead of directly writing to cout. We can overload this function for a version that returns a string object:

\begin{lstlisting}[style=styleCXX]
template<typename I>
string join(I it, I end_it, string_view sep = "") {
	ostringstream ostr;
	join(it, end_it, ostr, sep);
	return ostr.str();
}
\end{lstlisting}

This also goes in the bw namespace. This function creates an ostringstream object to pass to the ostream version of bw::join(). It returns a string object from the str() method of the ostringstream object.

We can use it like this:

\begin{lstlisting}[style=styleCXX]
string s = bw::join(greek.begin(), greek.end(), ", ");
cout << s << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
alpha, beta, gamma, delta, epsilon
\end{tcblisting}

\item 
Let's add one final overload to make this easier to use:

\begin{lstlisting}[style=styleCXX]
string join(const auto& c, string_view sep = "") {
	return join(begin(c), end(c), sep);
}
\end{lstlisting}

This version just takes a container and a separator, which should satisfy most use cases nicely:

\begin{lstlisting}[style=styleCXX]
string s = bw::join(greek, ", ");
cout << s << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
alpha, beta, gamma, delta, epsilon
\end{tcblisting}
\end{itemize}

\subsubsection{How it works…}

Most of the work in this recipe is done by the iterators and the ostream object:

\begin{lstlisting}[style=styleCXX]
namespace bw {
	template<typename I>
	ostream& join(I it, I end_it, ostream& o,
				string_view sep = "") {
		if(it != end_it) o << *it++;
		while(it != end_it) o << sep << *it++;
		return o;
	}
}
\end{lstlisting}

The separators go after the first element, between each of the successive elements, and stop before the final element. This means we can either add a separator before each element, skipping the first, or after each element, skipping the last. The logic is simpler if we test for, and skip, the first element. We do that in the line just before the while() loop:

\begin{lstlisting}[style=styleCXX]
if(it != end_it) o << *it++;
\end{lstlisting}

Once we have the first element out of the way, we can simply add a separator before each remaining element:

\begin{lstlisting}[style=styleCXX]
while(it != end_it) o << sep << *it++;
\end{lstlisting}

We return the ostream object as a convenience. This allows the user to easily add a newline, or other objects, to the stream:

\begin{lstlisting}[style=styleCXX]
bw::join(greek.begin(), greek.end(), cout, ", ") << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
alpha, beta, gamma, delta, epsilon
\end{tcblisting}

\subsubsection{There's more…}

As with any of the library algorithms, the join() function will work with any container that supports forward iterators. For example, here's a list of double constants from the numbers library:

\begin{lstlisting}[style=styleCXX]
namespace num = std::numbers;
list<double> constants { num::pi, num::e, num::sqrt2 };
cout << bw::join(constants, ", ") << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
3.14159, 2.71828, 1.41421
\end{tcblisting}

It will even work with a ranges::view object, like the greek\_view defined earlier in this recipe:

\begin{lstlisting}[style=styleCXX]
cout << bw::join(greek_view, ":") << '\n';
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
a:l:p:h:a:b:e:t:a:g:a:m:m:a:d:e:l:t:a:e:p:s:i:l:o:n
\end{tcblisting}

