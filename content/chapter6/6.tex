
The algorithm library contains a set of functions for finding elements in a container.
The std::find() function, and its derivatives, search sequentially through a container and return an iterator pointing to the first matching element, or the end() element if there's no match.

\subsubsection{How to do it…}

The find() algorithm works with any container that satisfies the Forward or Input iterator qualifications. For this recipe, we'll use vector containers. The find() algorithm searches sequentially for the first matching element in a container. In this recipe, we'll walk through a few examples:

\begin{itemize}
\item 
We'll start by declaring a vector of int in the main() function:

\begin{lstlisting}[style=styleCXX]
int main() {
	const vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	...
}
\end{lstlisting}

\item 
Now, let's search for the element with the value 7:

\begin{lstlisting}[style=styleCXX]
auto it1 = find(v.begin(), v.end(), 7);
if(it1 != v.end()) cout << format("found: {}\n", *it1);
else cout << "not found\n";
\end{lstlisting}

The find() algorithm takes three arguments: the begin() and end() iterators, and the value to search. It returns an iterator to the first element it finds, or the end() iterator if the search failed to find a match.

Output:

\begin{tcblisting}{commandshell={}}
found: 7
\end{tcblisting}

\item 
We can also search for something more complex than a scalar. The object needs to support the equality comparison operator, ==. Here's a simple struct with an operator==() overload:

\begin{lstlisting}[style=styleCXX]
struct City {
	string name{};
	unsigned pop{};
	bool operator==(const City& o) const {
		return name == o.name;
	}
	string str() const {
		return format("[{}, {}]", name, pop);
	}
};
\end{lstlisting}

Notice that the operator=() overload only compares the name members.

I've also included an str() function that returns a string representation of a City element.

\item 
Now we can declare a vector of City elements:

\begin{lstlisting}[style=styleCXX]
const vector<City> c{
	{ "London", 9425622 },
	{ "Berlin", 3566791 },
	{ "Tokyo", 37435191 },
	{ "Cairo", 20485965 }
};
\end{lstlisting}

\item 
We can search the vector of City just as we did with the vector of int:

\begin{lstlisting}[style=styleCXX]
auto it2 = find(c.begin(), c.end(), City{"Berlin"});
if(it2 != c.end()) cout << format("found: {}\n",
	it2->str());
else cout << "not found\n";
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
found: [Berlin, 3566791]
\end{tcblisting}

\item 
If we want to search on the pop member instead of name, we can use the find\_if() function with a predicate:

\begin{lstlisting}[style=styleCXX]
auto it3 = find_if(begin(c), end(c),
	[](const City& item)
		{ return item.pop > 20000000; });
if(it3 != c.end()) cout << format("found: {}\n",
	it3->str());
else cout << "not found\n";
\end{lstlisting}

The predicate tests the pop member, so we get this output:

\begin{tcblisting}{commandshell={}}
found: [Tokyo, 37435191]
\end{tcblisting}

\item 
Notice that the result from find\_if() returns only the first element that satisfies the predicate, even though there are two elements in the vector with pop values greater than 20,000,000.

The find() and find\_if() functions return only one iterator. The ranges library provides ranges::views::filter(), a view adapter that will give us all the matching iterators without disturbing our vector:

\begin{lstlisting}[style=styleCXX]
auto vw1 = ranges::views::filter(c,
	[](const City& c){ return c.pop > 20000000; });
for(const City& e : vw1) cout << format("{}\n", e.str());
\end{lstlisting}

This gives us both matching elements in our output:

\begin{tcblisting}{commandshell={}}
[Tokyo, 37435191]
[Cairo, 20485965]
\end{tcblisting}
\end{itemize}

\subsubsection{How it works…}

The find() and find\_if() functions search sequentially through a container, checking each element until it finds a match. If it finds a match, it returns an iterator pointing to that match. If it reaches the end() iterator without finding a match, it returns the end() iterator to indicate no match was found.

The find() function takes three arguments, the begin() and end() iterators, and a search value. The signature looks like this:

\begin{lstlisting}[style=styleCXX]
template<class InputIt, class T>
constexpr InputIt find(InputIt, InputIt, const T&)
\end{lstlisting}

The find\_if() function uses a predicate instead of a value:

\begin{lstlisting}[style=styleCXX]
template<class InputIt, class UnaryPredicate>
constexpr InputIt find_if(InputIt, InputIt, UnaryPredicate)
\end{lstlisting}


\subsubsection{There's more…}

Both find() functions search sequentially and return when they find the first match. If you want to find more matching elements, you can use the filter() function from the ranges library:

\begin{lstlisting}[style=styleCXX]
template<ranges::viewable_range R, class Pred>
constexpr ranges::view auto ranges::views::filter(R&&, Pred&&);
\end{lstlisting}

The filter() function returns a view, a non-destructive window into the container with only the filtered elements. We can then use the view as we would any other container:

\begin{lstlisting}[style=styleCXX]
auto vw1 = std::ranges::views::filter(c,
	[](const City& c){ return c.pop > 20000000; });
for(const City& e : vw1) cout << format("{}\n", e.str());
\end{lstlisting}

Output:

\begin{tcblisting}{commandshell={}}
[Tokyo, 37435191]
[Cairo, 20485965]
\end{tcblisting}
